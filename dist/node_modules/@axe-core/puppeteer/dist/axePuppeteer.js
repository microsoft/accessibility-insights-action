"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxePuppeteer = void 0;
const browser_1 = require("./browser");
function arrayify(src) {
    if (!Array.isArray(src)) {
        return [src];
    }
    return src;
}
function injectJSModule(frame) {
    return frame.addScriptTag({
        path: require.resolve('axe-core')
    });
}
function injectJSSource(frame, source, args = []) {
    return frame.evaluate(source, ...args);
}
function injectJS(frame, { source, selector, logOnError, args }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!frame) {
            return;
        }
        const frames = yield frame.$$(selector);
        const injections = [];
        for (const frameElement of frames) {
            const subFrame = yield frameElement.contentFrame();
            const p = injectJS(subFrame, {
                source,
                selector,
                args,
                logOnError: true
            });
            injections.push(p);
        }
        const reportError = () => {
            console.error(`Failed to inject axe-core into frame (${frame.url()})`);
        };
        let injectP;
        if (!source) {
            injectP = injectJSModule(frame);
        }
        else {
            injectP = injectJSSource(frame, source, args);
        }
        if (logOnError) {
            injectP = injectP.catch(reportError);
        }
        injections.push(injectP);
        return Promise.all(injections).then(() => undefined);
    });
}
function isPage(pageFrame) {
    return pageFrame.mainFrame !== undefined;
}
function getFrame(pageFrame) {
    if (isPage(pageFrame)) {
        return pageFrame.mainFrame();
    }
    return pageFrame;
}
function ensureFrameReady(frame) {
    return __awaiter(this, void 0, void 0, function* () {
        yield frame.waitForSelector('html');
        const pageReady = yield frame.evaluate(browser_1.pageIsLoaded);
        if (!pageReady) {
            throw new Error('Page/Frame is not ready');
        }
    });
}
function normalizeContext(includes, excludes) {
    if (!excludes.length && !includes.length) {
        return null;
    }
    const ctx = {};
    if (excludes.length) {
        ctx.exclude = excludes;
    }
    if (includes.length) {
        ctx.include = includes;
    }
    return ctx;
}
class AxePuppeteer {
    constructor(pageFrame, source) {
        this.frame = getFrame(pageFrame);
        this.source = source;
        this.includes = [];
        this.excludes = [];
        this.axeOptions = null;
        this.config = null;
        this.disabledFrameSelectors = [];
    }
    include(selector) {
        selector = arrayify(selector);
        this.includes.push(selector);
        return this;
    }
    exclude(selector) {
        selector = arrayify(selector);
        this.excludes.push(selector);
        return this;
    }
    options(options) {
        this.axeOptions = options;
        return this;
    }
    withRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'rule',
            values: rules
        };
        return this;
    }
    withTags(tags) {
        tags = arrayify(tags);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'tag',
            values: tags
        };
        return this;
    }
    disableRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        const newRules = {};
        for (const rule of rules) {
            newRules[rule] = {
                enabled: false
            };
        }
        this.axeOptions.rules = newRules;
        return this;
    }
    configure(config) {
        if (typeof config !== 'object') {
            throw new Error('AxePuppeteer needs an object to configure. See axe-core configure API.');
        }
        this.config = config;
        return this;
    }
    disableFrame(selector) {
        this.disabledFrameSelectors.push(selector);
        return this;
    }
    analyze(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield ensureFrameReady(this.frame);
                yield injectJS(this.frame, {
                    source: this.source,
                    selector: this.iframeSelector()
                });
                yield injectJS(this.frame, {
                    source: browser_1.configureAxe,
                    selector: this.iframeSelector(),
                    args: [this.config]
                });
                const context = normalizeContext(this.includes, this.excludes);
                const axeResults = yield this.frame.evaluate(browser_1.runAxe, context, this.axeOptions);
                if (callback) {
                    callback(null, axeResults);
                }
                return axeResults;
            }
            catch (err) {
                if (callback) {
                    callback(err);
                    return null;
                }
                throw err;
            }
        });
    }
    iframeSelector() {
        let selector = 'iframe';
        for (const disabledFrameSelector of this.disabledFrameSelectors) {
            selector += `:not(${disabledFrameSelector})`;
        }
        return selector;
    }
}
exports.AxePuppeteer = AxePuppeteer;
//# sourceMappingURL=axePuppeteer.js.map